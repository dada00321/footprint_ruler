import cv2 as cv2
import numpy as np
import os

class Homography():
	def __init__(self, output_folder_name, col_first_pasted_locs):
		# Create Directory
		dir_path = f"result/{output_folder_name}"
		os.mkdir(dir_path) if not os.path.exists(dir_path) else None
		dir_path += "/(2)_image_homography"
		os.mkdir(dir_path) if not os.path.exists(dir_path) else None
		self.dir_path = dir_path
		
		# pasted_locs below are locations of the foot bounding box 
		# PS. "pasted image", i.e. "left-view image"
		self.pasted_img_x = col_first_pasted_locs[0]
		self.pasted_img_y = col_first_pasted_locs[1]
		self.pasted_img_foot_w = col_first_pasted_locs[2]
		self.pasted_img_foot_h = col_first_pasted_locs[3]

	# This function will get click pixel coordinate that source image will be pasted to destination image
	def collect_pasted_locs(self, event, x, y, flags, pasted_locs_list):
		cv2.imshow("collect coordinate", self.img_pasted_copy)
		if event == cv2.EVENT_LBUTTONUP:
			# Draw circle right in click position
			cv2.circle(self.img_pasted_copy, (x, y), 2, (0, 0, 255), -1)
			# Append new clicked coordinate to pasted_locs_list
			pasted_locs_list.append([x, y])
			
	def projective_transform(self):
		# Load left-view and right view image generated by program `two_viewers.py` previously
		img_copied = cv2.imread("./ROI_cropped.jpg", cv2.IMREAD_COLOR)
		cv2.imshow("img_copied", img_copied)
		cv2.imwrite(f"{self.dir_path}/(1)_img_copied.jpg", img_copied)

		h_copied, w_copied, _ = img_copied.shape
		locs_copied = np.array([[0,0],[0,h_copied],[w_copied,0],[w_copied,h_copied]])
		
		img_pasted = cv2.imread("./img_with_bbox_and_text.jpg", cv2.IMREAD_COLOR)

		# Copy destination image
		self.img_pasted_copy = img_pasted.copy()#np.tile(img_pasted, 1)
		
		# `locs_pasted` in destination image
		"""
		locs_pasted = list()
		cv2.namedWindow("collect coordinate")
		cv2.setMouseCallback("collect coordinate", self.collect_locs_pasted, locs_pasted)
		while True:
			cv2.waitKey(1)
			if len(locs_pasted) == 4:
				break
		locs_pasted = np.array(locs_pasted)
		"""
		
		# Obtain perspective (homography) matrix & projection image
		h, w = self.pasted_img_foot_h, self.pasted_img_foot_w
		locs_pasted = np.array([[0,0],[0,h],[w,0],[w,h]])
		
		# Calculate homography matrix
		print()
		print(f"height of copied image: {h_copied}")
		print(f"width of copied image: {w_copied}")
		print("---"*10)
		print(f"height of pasted image: {h}")
		print(f"width of pasted image: {w}")
		matrix, _ = cv2.findHomography(locs_copied, locs_pasted, 0)
		
		print()
		print(f"matrix: {matrix}")
		
		img_perspective = cv2.warpPerspective(img_copied, matrix, (img_pasted.shape[1], img_pasted.shape[0]))
		cv2.imshow("perspective image (right-view)", img_perspective)
		cv2.imwrite(f"{self.dir_path}/(2)_perspective image (right-view).jpg", img_perspective)
		cv2.imshow("pasted image (left-view + bounding box)", img_pasted)
		cv2.imwrite(f"{self.dir_path}/(3)_pasted image (left-view + bounding box).jpg", img_pasted)
		cv2.waitKey(0)
		
		'''
		cv2.copyTo(src=img_perspective, mask=np.tile(img_perspective, 1), dst=img_projection)
		cv2.imshow("projection", img_projection)
		'''
		
		# Merge left-view and right-view images called `img_footprint`
		
		img_footprint = img_pasted.copy()
		
		## Firstly, clear all pixels in bounding box to zeros 
		x,y,h,w = self.pasted_img_x,self.pasted_img_y,self.pasted_img_foot_h,self.pasted_img_foot_w
		###y_center = (2*y+h)//2
		x_center = (2*x+w)//2
		x_center_v2 = (0+w)//2
		img_footprint[y+2:(y+h), x_center:(x+w)] = (0,0,0)
		cv2.imshow("pasted image v2 (left-view + bounding box)", img_footprint)
		cv2.imwrite(f"{self.dir_path}/(4)_pasted image v2 (left-view + bounding box).jpg", img_footprint)
		
		## Secondly, paste part of left-view image `img_footprint` to fill the left part in `img_pasted`
		#img_footprint[y:y_center,x:x_center,:] = 
		#img_footprint[y+2:(y+h), x_center:(x+w)] = img_perspective[0:(h-2), 0:]
		delta_x_right_part = (x+w) - x_center
		tmp = img_perspective[0:(h-2), x_center_v2:(x_center_v2+delta_x_right_part)]
		cv2.imshow("tmp", tmp)
		cv2.imwrite(f"{self.dir_path}/(5)_tmp.jpg", tmp)
		
		img_footprint[y+2:(y+h), x_center:(x+w)] = tmp
		#img_footprint[y+2:(y+h), x_center:(x+w)] = img_perspective[0:(h-2), x_center:(x+w)]
		cv2.imshow("pasted image v3 (left-view + bounding box)", img_footprint)
		cv2.imwrite(f"{self.dir_path}/(6)_pasted image v3 (left-view + bounding box).jpg", img_footprint)
		
		# Close windows
		cv2.waitKey(0)
		cv2.destroyAllWindows()
		#cv2.bitwise_or(img_footprint, )
		return img_footprint
	
	def denoise(self, img_footprint, col_first_coordinates):
		''' Step 1. Swap the black and white pixels '''
		gray = cv2.cvtColor(img_footprint, cv2.COLOR_BGR2GRAY)  

		''' Step 2. Denoise: Using morphology operations '''
		# [+]: dilate (若沒做 [形態學-膨脹], bbox 只會框到白色目標物內部的小黑孔洞)
		gray = cv2.dilate(gray, None) # 膨脹 => 目標: 補洞 (填補白色物體內部的小洞)
		ret, binary_inv = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)  
		cv2.imshow("binary_inv", binary_inv)
		cv2.imwrite(f"{self.dir_path}/(7)_binary_inv.jpg", binary_inv)
		
		"""
		#o = binary_inv
		#cv2.imshow("original",o)  
		#gray = cv2.cvtColor(o,cv2.COLOR_BGR2GRAY)  
		#ret, binary = cv2.threshold(gray,127,255,cv2.THRESH_BINARY)  
		#contours, hierarchy = cv2.findContours(binary,
		contours, hierarchy = cv2.findContours(binary_inv, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)  
		#mask=np.zeros(o.shape,np.uint8)
		mask=np.zeros(binary_inv.shape,np.uint8)
		mask=cv2.drawContours(mask,contours,-1,(255,255,255),-1) 
		cv2.imshow("mask", mask)
		#loc=cv2.bitwise_and(o,mask)
		loc=cv2.bitwise_and(binary_inv, mask)
		cv2.imshow("location", loc)
		cv2.waitKey()
		cv2.destroyAllWindows()
		"""
		#---
		"""
		#ret = cv2.bitwise_not(binary_inv, binary_inv)
		ret = binary_inv - binary_inv
		cv2.imshow("ret", ret)
		
		o = cv2.imread('contours.bmp')  
		cv2.imshow("original",o)
		gray = cv2.cvtColor(o,cv2.COLOR_BGR2GRAY)  
		ret, binary = cv2.threshold(gray,127,255,cv2.THRESH_BINARY)  
		#image,contours, hierarchy = cv2.findContours(binary,
		contours, hierarchy = cv2.findContours(binary,
		                                             cv2.RETR_EXTERNAL,
		                                             cv2.CHAIN_APPROX_SIMPLE)  
		o=cv2.drawContours(o,contours,-1,(0,0,255),5) 
		cv2.imshow("result",o)    
		cv2.waitKey()
		cv2.destroyAllWindows()
		"""
		
		''' Step 3. Parse the coordinates of the footprint's bounding box '''
		x2, y2, foot_w2, foot_h2 = col_first_coordinates
		binary_inv_cropped = binary_inv[y2+3:y2+foot_h2-2, x2+3:x2+foot_w2-2]
		cv2.imshow("binary_inv_cropped", binary_inv_cropped)
		cv2.imwrite(f"{self.dir_path}/(8)_binary_inv_cropped.jpg", binary_inv_cropped)
		
		''' Step 4. Contour Detection: Use `findContours()` to select all the contours '''
		#gray = cv2.cvtColor(o,cv2.COLOR_BGR2GRAY)  
		#ret, binary = cv2.threshold(gray,127,255,cv2.THRESH_BINARY)  
		#image,contours, hierarchy = cv2.findContours(binary,
		#contours, hierarchy = cv2.findContours(binary,
		#contours, hierarchy = cv2.findContours(binary_inv,
		contours, hierarchy = cv2.findContours(binary_inv_cropped,
		                                       cv2.RETR_EXTERNAL,
		                                       cv2.CHAIN_APPROX_SIMPLE)  
		binary_inv_cropped_rgb = cv2.cvtColor(binary_inv_cropped, cv2.COLOR_GRAY2BGR)  
		binary_inv_with_contours = binary_inv_cropped_rgb.copy()
		cv2.drawContours(binary_inv_with_contours,contours,-1,(0,0,255),5) 
		cv2.imshow("binary_inv_with_contours", binary_inv_with_contours)
		cv2.imwrite(f"{self.dir_path}/(9)_binary_inv_with_contours.jpg", binary_inv_with_contours)
		cv2.waitKey(0)
		cv2.destroyAllWindows()
		
		''' Step 5: Contour Selection 
		##          // I figured out several ways to do this process
		##          // but as an example, the demo use-case only takes the simplest way
		##          // i.e. Directly specify the contour index (among all contours) XD
		## 
		##          Check each contour intersect (meet) the coners of b-box or not,
		##          [Case-1] 
		##             If they're intersect, 
		##             represents this contour is a region out of the footprint
		##             we can neglect it.
		##          [Case-2] 
		##             If they're not intersect, 
		##             represents this contour is a region in the footprint
		##             we can recolorize it as black to denoise it.
		'''
		#bounding_box_corners = [x2,y2,foot_w2,foot_h2]
		#bounding_box_corners = [[y2, x2], [y2+foot_h2, x2],
		#				        [y2, x2+foot_w2], [y2+foot_h2, x2+foot_w2]]
		
		# @Error
		# XXX
		#bounding_box_corners = [(y, x) for x in range(0, foot_w2) for y in range(0, foot_h2)]
		#bounding_box_corners = np.array(bounding_box_corners)
		# XXX
		
		# @Override
		h, w = binary_inv_cropped.shape
		bounding_box_corners = [(y, x) for x in range(0, w) for y in range(0, h)]
		#bounding_box_corners = np.array(bounding_box_corners)
		
		"""
		bounding_box_corners = [[0, 0], [foot_h2, 0],
						        [0, foot_w2], [foot_h2, foot_w2]]
		bounding_box_corners = np.array(bounding_box_corners)
		"""
		
		# @Original
		h, w = binary_inv_cropped.shape
		#new_bbox_corners = [(0, 0), (h, 0), (0, w), (h, w)]
		
		# @Override
		new_bbox_corners = bounding_box_corners
		
		#contour_points = dict()
		#[contour_points.setdefault(i+1, contours) for i, e in enumerate(contours)]
		
		list_of_contours = list()
		for contour in contours:
			list_of_contour = [tuple(point[0]) for point in contour]
			list_of_contours.append(list_of_contour)
		
		## Example: For one of contours,
		##          show "the number" of intersected points 
		##          between foot bounding box & each contour
		"""
		intersected_points = set(new_bbox_corners).intersection(set(list_of_contours[5]))
		#---
		print("\n(1) Example: A contour intersected in corner of foot bounding box (idx: 5)")
		print(set(list_of_contours[5]))
		print("\n(2) The 4 Corners of foot bounding box")
		print(set(new_bbox_corners))
		print("\n(3) Example: List all common elements")
		print(intersected_points)
		"""
		#print()
		#print("new_bbox_corners:", '\n', new_bbox_corners, sep='')
		print()
		#footprint_with_target_contour = binary_inv.copy()
		footprint_with_target_contour = binary_inv_cropped_rgb.copy()
		
		## Attempt: Use conditions to filter contour(s) inside the footprint
		### Result: Both contours inside & outside the footprint got filtered
		"""
		foot_bbox_corners = set(new_bbox_corners)
		for contour, list_of_contour in zip(contours, list_of_contours):
			intersected_points = set(list_of_contour).intersection(foot_bbox_corners)
			intersected_num = len(intersected_points)
			print("num of intersected:", intersected_num)
			if intersected_num == 0:
				cv2.drawContours(footprint_with_target_contour, contour, -1, (0,0,255), 5) 
		cv2.imshow("footprint_with_target_contour", footprint_with_target_contour)
		"""
		
		## Attempt: Directly indicate the specific contour
		### Result: Only a contour inside the footprint got filtered
		target_contour = contours[0]
		footprint_with_target_contour_v1 = footprint_with_target_contour.copy()
		cv2.drawContours(footprint_with_target_contour_v1, target_contour, -1, (255,0,0), 3) 
		cv2.imshow("footprint_with_target_contour - v1", footprint_with_target_contour_v1)
		cv2.imwrite(f"{self.dir_path}/(10)_footprint_with_target_contour - v1.jpg", footprint_with_target_contour_v1)

		## Attempt: Moreover, make a bounding box for the target contour
		x,y,w,h = cv2.boundingRect(target_contour)
		### Example: Show binary inversed footprint image
		###          with a target bouning box
		### (PS. target bouning box: A red bounding box on the target contour)
		colour = (0,0,255)
		thickness = 1
		footprint_with_target_contour_v2 = footprint_with_target_contour.copy()
		cv2.rectangle(footprint_with_target_contour_v2, (x,y), (x+w,y+h), colour, thickness)
		cv2.imshow("footprint_with_target_contour - v2", footprint_with_target_contour_v2)
		cv2.imwrite(f"{self.dir_path}/(11)_footprint_with_target_contour - v2.jpg", footprint_with_target_contour_v2)

		## Denoise
		#          Set the colours in target bouning box as "black"
		#          in the binary inversed footprint 
		#  PS. Originally, 
		#      Part (1) footprint: black
		#      Part (2) noises in footprint: white
		#      Part (3) regions between footprint and its bounding box: white
		#      This step will reset colours in part (2) to the black
		
		### Example: Show [cropped >> denoised] footprint image
		footprint_pure = footprint_with_target_contour.copy()
		footprint_pure[y:(y+h),x:(x+w)] = 0
		cv2.imshow("example: pure footprint (cropped)", footprint_pure)
		cv2.imwrite(f"{self.dir_path}/(12)_example__pure_footprint_(cropped).jpg", footprint_pure)
		
		### Example: Show denoised footprint image (uncropped)
		footprint_pure = binary_inv.copy()
		footprint_pure[y+y2:(y+h)+y2+3,x+x2:(x+w)+x2+3] = 0
		cv2.imshow("pure footprint", footprint_pure)
		cv2.imwrite(f"{self.dir_path}/(13)_pure_footprint.jpg", footprint_pure)
		
		''' Step 6: Convert the "binary inversed image" back to "binary image" ''' 
		ret, binary_inv_inv = cv2.threshold(footprint_pure, 127, 255, cv2.THRESH_BINARY_INV)  
		cv2.imshow("binary_inv_inv", binary_inv_inv)
		cv2.imwrite(f"{self.dir_path}/(14)_binary_inv_inv.jpg", binary_inv_inv)
		
		cv2.waitKey(0)
		cv2.destroyAllWindows()
		
		#mask = footprint_pure #XXX
		
		#!!!
		mask = binary_inv_inv 
		#!!!
		
		mask = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
		
		return mask
	
"""
if __name__ == "__main__":
	homo = Homography()
	homo.projective_transform()
"""
	